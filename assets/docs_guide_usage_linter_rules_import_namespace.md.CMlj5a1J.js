import{_ as o,c as r,j as e,a,I as s,o as n,E as i}from"./chunks/framework.D6UG3LSr.js";const k=JSON.parse('{"title":"import/namespace","description":"","frontmatter":{},"headers":[],"relativePath":"docs/guide/usage/linter/rules/import/namespace.md","filePath":"docs/guide/usage/linter/rules/import/namespace.md"}'),c={name:"docs/guide/usage/linter/rules/import/namespace.md"},d={id:"import-namespace",tabindex:"-1"},l=e("a",{class:"header-anchor",href:"#import-namespace","aria-label":'Permalink to "import/namespace <Badge type="info" text="Correctness" />"'},"​",-1),p=e("div",{class:"rule-meta"},null,-1),m=e("h3",{id:"what-it-does",tabindex:"-1"},[a("What it does "),e("a",{class:"header-anchor",href:"#what-it-does","aria-label":'Permalink to "What it does"'},"​")],-1),f=e("p",null,[a("Enforces names exist at the time they are dereferenced, when imported as a full namespace (i.e. "),e("code",null,"import * as foo from './foo'; foo.bar();"),a(" will report if bar is not exported by "),e("code",null,"./foo."),a("). Will report at the import declaration if there are no exported names found. Also, will report for computed references (i.e. "),e("code",null,'foo["bar"]()'),a("). Reports on assignment to a member of an imported namespace.")],-1);function h(u,_,g,x,b,B){const t=i("Badge");return n(),r("div",null,[e("h1",d,[a("import/namespace "),s(t,{type:"info",text:"Correctness"}),a(),l]),p,m,f])}const v=o(c,[["render",h]]);export{k as __pageData,v as default};
